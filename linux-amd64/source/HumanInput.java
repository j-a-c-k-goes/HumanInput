/* autogenerated by Processing revision 1292 on 2023-04-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class HumanInput extends PApplet {

// HumanInput.pde
PFont violetSans;
int hours = hour();
int minutes = minute();
int seconds = second();
public void setup() {
  /* size commented out by preprocessor */;
  /* smooth commented out by preprocessor */;
  noStroke();
  violetSans = createFont("violetsans.ttf", 48);
  textFont(violetSans);
  textAlign(LEFT, CENTER);
}
public void draw() {
  background(13);
  float sinWave = tan( radians( seconds * (frameCount*.5f) * ( noise( .0016f, .025f ) ) ) );
  // Star One
  pushMatrix();
  translate( width / 2, height / 2);
  fill( 255 - ( hours + ( seconds / 2 ) ), seconds * 7, 32 * ( minutes - seconds ) );
  drawStar();
  popMatrix();

  //Star Two
  pushMatrix();
  translate( width / 2, height / 2);
  //translate( mouseX, mouseY);
  rotate(TWO_PI * frameCount / width);
  translate(0, width / 5);
  fill(minutes * hours, seconds * 7, 255 - ( minutes * 2 ) );
  drawStar();
  popMatrix();

  pushMatrix();
  renderTime(16 + PApplet.parseInt(noise(seconds*sinWave)), height - 124, 24 * (sinWave*.28f));
  popMatrix();
}
public void renderTime(int xPosition, int yPosition, float leadingValue) {
  int h = hour();
  int m = minute();
  int s = second();
  String timestamp = h + " hours\n" + m + " minutes\n" + s + " seconds\n®™";
  fill(255);
  textSize(24);
  textLeading(24 + leadingValue);
  text(timestamp, xPosition, yPosition  );
}
public void drawStar() {
  float numberOfSpokes = ( width * height ) / ( ((24000000 / frameCount) * seconds) * (noise( .0016f, .025f )) );
  for (float i = 0; i < numberOfSpokes; ++i) {
    /*
     How map works here?
     Convert i:
     within current range
     lower bound 0
     upper bound numberOfSpokes - 1
     within target range
     lower bound 0
     upper bound TWO_PI (360 degrees)
     */
    float t0 = map(i, 0, numberOfSpokes - 1, 0, TWO_PI);
    float t1 = t0 + (TWO_PI/(2 * numberOfSpokes));

    // Arc: xCoordinate, yCoordinate, width, height, start, stop
    //rect(noise( hours *  t0), noise( hours *  t1), width*noise(seconds*i), height*noise(seconds*i));
    arc( noise( hours *  frameCount), noise( hours /  frameCount), width*noise(seconds), height, t0, t1);
  }
}


  public void settings() { size(368, 448);
smooth(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "HumanInput" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
